---
title: 笔记
date: 2021-05-11 14:30:00
permalink: /c/note/
author: 
    name: eric
    href: https://wfmiss.cn
---

# C语言笔记

[toc]

## C语言发展历程
- C语⾔是从B语⾔发展⽽来的，B语⾔是从`BCPL`发展⽽来的，`BCPL`是从 `FORTRAN`发展⽽来的。
- `BCPL`和B都⽀持指针间接⽅式，所以C也⽀持了。
- C语⾔还受到了`PL/1`的影响，还和`PDP-11`的机器语⾔有很⼤的关系。
- 1973年3⽉，第三版的`Unix`上出现了C语⾔的编译器。
- 1973年11⽉，第四版的`Unix（System Four）`发布了，这个版本是完全用C语言重新编写的。

### C的发展与版本-K&R
- 经典 C ----> ⼜被叫做 `“K&R the C”`
- The C Programming Language, by Brian Kernighan and Dennis Ritchie, 2nd Edition, Prentice Hall

### C的发展与版本-标准
- 1989年ANSI发布了⼀个标准——`ANSI C`
- 1990年ISO接受了ANSI的标准——C89
- C的标准在1995年和1999年两次更新——C95和C99
- **所有的当代编译器都⽀持C99了**

### C语⾔⽤在哪⾥？ 

- 操作系统 
- 嵌⼊式系统 
- 驱动程序 
- 底层驱动 
- 图形引擎、图像处理、声⾳效果

### C语言编译软件（IDE）
- Dev C++（4.9 for Win7, 5.0 for Win8）
- MS Visual Studio Express（Windows）
- Xcode（Mac OS X）
- Eclipse-CDT
- Geany（和MinGW⼀起）
- Sublime（和MinGW⼀起）
- vim/emacs（和MinGW⼀起）

## C语言基础
**编写代码注意：代码里的符号一定要是英文状态下的标点符号！！！，不要用中文！！！**
### 第一章 基础语法
#### 1、输出函数
`printf("Hello World!\n");`
`""`⾥⾯的内容叫做`“字符串”`，printf会把其中的内容原封不动地输出
` \n `表⽰需要在输出的结果后⾯换⼀⾏。

补充：
- 如果你在使⽤Dev C++ 4.9.9.2
`system("pause");`
- 让程序运⾏完成后，窗⼝还能留下
- 不是Dev C++ 4.9.9.2就不需要这个了

#### 2、运算符

**算数运算符**
|C符号|意义|
|:---:|:---:|
|+|加|
|-|减|
|`*`|乘|
|/|除|
|%|取余|
|()|括号|
|++|自增|
|--|自减|

**关系运算符**
|C符号|意义|
|:---:|:---:|
|>|大于|
|<|小于|
|==|等于|
|>=|大于等于|
|<=|小于等于|
|!=|不等于|

**逻辑运算符**
|C符号|意义|
|:---:|:---:|
|！|非|
|&&|与|
|`||`|或|

位运算符：【>>,<<,~,|,^,&】
赋值运算符：【`=`】
条件运算符（三元运算符）：【`常量表达式？返回值1:返回值2;`】
逗号运算符：【`,`】
指针运算符：【`*`,&】
求字节数运算符：【`sizeof`】

#### 3、变量定义
变量定义的⼀般形式就是：`<类型名称> <变量名称>;`
例如：`int a;`

#### 4、变量的名字
- 变量需要⼀个名字，变量的名字是⼀种“标识符”，意思是它是⽤来识别这个和那个的不同的名字。
- 标识符有标识符的构造规则。基本的原则是：标识符只能由字⺟、数字和下划线组成，数字不可以出现在第⼀个位置上，C语⾔的关键字（有的地⽅叫它们保留字）不可以⽤做标识符。
**C语⾔的保留字：**
auto、break、case、char、const 、continue、default、do、double 、else、enum、extern、float、for、goto、if、int、long、register、return、short、signed、sizeof、static、 struct、switch、typedef、union、unsigned、void、volatile、while、inline、restrict
**赋值和初始化**
`int price = 0;`
这⼀⾏，定义了⼀个变量。变量的名字是`price`，类型是`int`，初始值是`0`。
这⾥的`“＝”`是⼀个赋值运算符，表⽰将`“＝”`右边的值赋给左边的变量。

#### 5、变量初始化
如果没有进行初始化变量，直接使用，运算出来的结果会是一个很奇怪的值。
格式为：`<类型名称> <变量名称> = <初始值>;`
> 当赋值发⽣在定义变量的时候，就像程序1中的第7⾏那样，就是变量的初始化。虽然C语⾔并没有强制要求所有的变量都在定义的地⽅做初始化，但是所有的变量在第⼀次被使⽤（出现在赋值运算符的右边）之前被应该赋值⼀次。

#### 6、变量类型
C是⼀种有类型的语⾔，所有的变量在使⽤之前必须定义或声明，所有的变量必须具有确定的数据类型。数据类型表⽰在变量中可以存放什么样的数据，变量中只能存放指定类型的数据，程序运⾏过程中也不能改变变量的类型。

**六种基本数据类型。**

|变量类型|说明|字节大小|
|:---:|:---:|:---:|
|char|字符型类型|1|
|short|短整型类型|2|
|int|整型类型|4|
|long|长整型类型|4or8|
|float|单精度浮点类型|4|
|double|双精度浮点类型|8|

- `signed`:有符号，可省略
- `unsigned`:无符号

#### 7、常量

C99允许使用**常变量**，方法是在定义变量时，前面加一个关键字`const`。
符号常量`#define`：用法`#define 常量名 值 `，注意行末没有分号。

#### 8、转义字符
转义字符及其作用



![](https://cdn.jsdelivr.net/gh/wfmiss/pictures/C_language/20210510175613.png)

#### 9、输入函数
`scanf(“格式控制字符串”, 地址表列);`
格式控制字符串的作用与printf函数相同，但不能显示非格式字符串，也就是不能显示提示字符串。地址表列中给出各变量的地址。地址是由地址运算符“&”后跟变量名组成的。
例如：
```C
#include <stdio.h>
int main(void){
    int a,b,c;
    printf("input a,b,c\n");
    scanf("%d%d%d",&a,&b,&c);
    printf("a=%d,b=%d,c=%d",a,b,c);
    return 0;
}
```

** 格式字符串**
格式字符串的一般形式为：
`%[*][输入数据宽度][长度]类型`
其中有方括号[]的项为任选项。各项的意义如下。
**类型**
表示输入数据的类型，其格式符和意义如下表所示。

|  格式  |             字符意义             |
| :----: | :------------------------------: |
|   %d   |          输入十进制整数          |
|   %o   |          输入八进制整数          |
|   %x   |         输入十六进制整数         |
|   %u   |       输入无符号十进制整数       |
| %f或%e | 输入实型数(用小数形式或指数形式) |
|   %c   |           输入单个字符           |
|   %s   |            输入字符串            |

**使用scanf函数还必须注意以下几点：**

1. scanf函数中没有精度控制，如：scanf("%5.2f",&a);是非法的。不能企图用此语句输入小数为2位的实数。
2. scanf中要求给出变量地址，如给出变量名则会出错。如 scanf("%d",a);是非法的，应改为scnaf("%d",&a);才是合法的。
3. 在输入多个数值数据时，若格式控制串中没有非格式字符作输入数据之间的间隔则可用空格，TAB或回车作间隔。C编译在碰到空格，TAB，回车或非法数据(如对“%d”输入“12A”时，A即为非法数据)时即认为该数据结束。
4. 在输入字符数据时，若格式控制串中无非格式字符，则认为所有输入的字符均为有效字符。

**printf格式附加字符**

|       字符        |                          说明                          |
| :---------------: | :----------------------------------------------------: |
|         l         |         长整型整数，可加在格式符d、o、x、u前面         |
| m(代表一个正整数) |                      数据最小宽度                      |
| n(代表一个正整数) | 对实数，表示输出n位小数；对字符串，表示截取的字符个数; |
|         -         |               输出的数字或字符域内向左靠               |

一般形式为：`% 附加字符 格式字符`

**scanf格式附加字符**
| 字符 |                             说明                             |
| :--: | :----------------------------------------------------------: |
|  l   | 输入长整型数据（可用%ld，%lo，%lx，%lu）以及double型数据（用%lf或%le） |
|  h   |             输入短整型数据（可用%hd，%ho，%hx）              |
| 域宽 |       指定输入输入数据所占宽度（列数），宽域应为正整数       |
| `*`  |                本输入项在读入后不赋给相应变量                |

#### 10、运算符优先级和结合性

![](https://cdn.jsdelivr.net/gh/wfmiss/pictures/C_language/20210511161914.png)
![](https://cdn.jsdelivr.net/gh/wfmiss/pictures/C_language/20210511161913.png)
![](https://cdn.jsdelivr.net/gh/wfmiss/pictures/C_language/20210511161912.png)

**上表中可以总结出如下规律：**

1. 结合方向只有三个是从右往左，其余都是从左往右。
2. 所有双目运算符中只有赋值运算符的结合方向是从右往左。
3. 另外两个从右往左结合的运算符也很好记，因为它们很特殊：一个是单目运算符，一个是三目运算符。
4. C语言中有且只有一个三目运算符。
5. 逗号运算符的优先级最低，要记住。
6. 此外要记住，对于优先级：算术运算符 > 关系运算符 > 逻辑运算符 > 赋值运算符。逻辑运算符中“逻辑非 !”除外。

#### 11、一些容易出错的优先级问题

上表中，优先级同为1 的几种运算符如果同时出现，那怎么确定表达式的优先级呢？这是很多初学者迷糊的地方。下表就整理了这些容易出错的情况：

| 优先级问题                                        | 表达式               | 经常误认为的结果                                          | 实际结果                                                     |
| ------------------------------------------------- | -------------------- | --------------------------------------------------------- | ------------------------------------------------------------ |
| `.` 的优先级高于 `*`（-> 操作符用于消除这个问题） | `*`p.f               | p 所指对象的字段 f，等价于： (`*`p).f                     | 对 p 取 f 偏移，作为指针，然后进行解除引用操作，等价于： `*`(p.f) |
| [] 高于 `*`                                       | int `*`ap[]          | ap 是个指向 int 数组的指针，等价于： int (`*`ap)[]        | ap 是个元素为 int 指针的数组，等价于： int `*`(ap [])        |
| 函数 () 高于 `*`                                  | int `*`fp()          | fp 是个函数指针，所指函数返回 int，等价于： int (`*`fp)() | fp 是个函数，返回 int`*`，等价于： int`* `( fp() )           |
| == 和 != 高于位操作                               | (val & mask != 0)    | (val &mask) != 0                                          | val & (mask != 0)                                            |
| == 和 != 高于赋值符                               | c = getchar() != EOF | (c = getchar()) != EOF                                    | c = (getchar() != EOF)                                       |
| 算术运算符高于位移 运算符                         | msb << 4 + lsb       | (msb << 4) + lsb                                          | msb << (4 + lsb)                                             |
| 逗号运算符在所有运 算符中优先级最低               | i = 1, 2             | i = (1,2)                                                 | (i = 1), 2                                                   |

#### 12、不同类型数据间的混合运算
（1）+、-、`*`、/、运算符两侧中有一个为float或double型，结果都为double型数据。
（2）如果 int型与float型数据进行运算，会先把int型和和float型数据转换为double型，然后再进行运算，结果是double型
（3）字符（char）型数据与整形数据进行运算，就是把字符型数据的ASCLL代码与整形数据进行运算。如：12+'A'等效于12+65结果为77，字符型数据与实型数据进行运算，则会将字符型的ASCLL代码转换为double型数据然后再进行运算。
**以上的转换都是由编译器自动完成转换的，知道其转换的原理即可，不用自己进行转换。**

### 第二章、控制语句
- if…else…		条件语句
- for()…		循环语句
- whille()…		  循环语句
- do…whille()	  循环语句
- continue		结束本次循环
- break	 		终止执行switch或循环语句
- switch		多分支语句
- return		从函数返回语句
- goto		 	转向语句，在结构化程序中基本不用goto语句

#### 1. 字符输入输出函数

`putchar`输出一个字符

`getchar`输入一个字符

#### 2. 选择结构嵌套

```c
if(){
    if()语句；
    else()语句；
}
else{
    if()语句；
    else()语句；
}
```

#### 3. switch多分支

```c
switch(表达式)
{
    case 常量1:语句1;break;
    case 常量2:语句2;break;
        ……
    case 常量n:语句n;break;
    default :语句 n+1;break;
}
```

由于用法基本一致，其余不做详细介绍。请参考：《C语言程序设计（第五版）》——谭浩强 【第五章-循环结构 -110页】 

### 第三章、数组【一维数组、多维数组】

#### 1. 一维数组

一维数组的定义方式为：
`类型说明符 数组名 [常量表达式];`
其中，类型说明符是任一种基本数据类型或构造数据类型。数组名是用户定义的数组标识符。方括号中的常量表达式表示数据元素的个数，也称为数组的长度。例如：

```c
int a[10]; 				 /* 说明整型数组a，有10个元素 */
float b[10], c[20];  	 /* 说明实型数组b，有10个元素，实型数组c，有20个元素 */
char ch[20];  			 /* 说明字符数组ch，有20个元素 */
```
**对于数组类型说明应注意以下几点：**
1) 数组的类型实际上是指数组元素的取值类型。对于同一个数组，其所有元素的数据类型都是相同的。
2) 数组名的书写规则应符合标识符的书写规定。
3) 数组名不能与其它变量名相同。例如：
```c
int a;
float a[10];
```
是错误的。

4) 方括号中常量表达式表示数组元素的个数，如a[5]表示数组a有5个元素。但是其下标从0开始计算。因此5个元素分别为a[0], a[1], a[2], a[3], a[4]。

5) 不能在方括号中用变量来表示元素的个数，但是可以是符号常数或常量表达式。例如：

```c
#define FD 5	// 宏定义，FD为常量（值不可改变）
int a[3+2],b[7+FD];
```
是合法的。但是下述说明方式是错误的。
```c
int n=5;
int a[n];
```
6) 允许在同一个类型说明中，说明多个数组和多个变量。例如：
```c
int a,b,c,d,k1[10],k2[20];
```

**一维数组元素的引用**
数组元素是组成数组的基本单元。数组元素也是一种变量， 其标识方法为数组名后跟一个下标。下标表示了元素在数组中的顺序号。数组元素的一般形式为：
`数组名[下标]`
其中下标只能为整型常量或整型表达式。如为小数时，C编译将自动取整。例如：
  a[5]
  a[i+j]
  a[i++]
都是合法的数组元素。

数组元素通常也称为下标变量。必须先定义数组，才能使用下标变量。在C语言中只能逐个地使用下标变量，而不能一次引用整个数组。

**一维数组的初始化**

一维数组的初始化可以使用以下方法实现:
1) 定义数组时给所有元素赋初值，这叫“完全初始化”。例如：

```
int a[5] = {1, 2, 3, 4, 5};
```

通过将数组元素的初值依次放在一对花括号中，如此初始化之后，a[0]=1；a[1]=2；a[2]=3；a[3]=4；a[4]=5，即从左到右依次赋给每个元素。需要注意的是，初始化时各元素间是用逗号隔开的，不是用分号。

2) 可以只给一部分元素赋值，这叫“不完全初始化”。例如：

```
int a[5] = {1, 2};
```

定义的数组 a 有 5 个元素，但花括号内只提供两个初值，这表示只给前面两个元素 a[0]、a[1] 初始化，而后面三个元素都没有被初始化。不完全初始化时，没有被初始化的元素自动为 0。

需要注意的是，“不完全初始化”和“完全不初始化”不一样。如果“完全不初始化”，即只定义“int a[5]；”而不初始化，那么各个元素的值就不是0了，所有元素都是垃圾值。

你也不能写成“int a[5]={}；”。如果大括号中什么都不写，那就是极其严重的语法错误。大括号中最少要写一个数。比如“int a[5]={0}；”，这时就是给数组“清零”，此时数组中每个元素都是零。此外，如果定义的数组的长度比花括号中所提供的初值的个数少，也是语法错误，如“a[2]={1，2，3，4，5}；”。

3) 如果定义数组时就给数组中所有元素赋初值，那么就可以不指定数组的长度，因为此时元素的个数已经确定了。编程时我们经常都会使用这种写法，因为方便，既不会出问题，也不用自己计算有几个元素，系统会自动分配空间。例如：

```
int a[5] = {1, 2, 3, 4, 5};
```

可以写成：

```
int a[] = {1, 2, 3, 4, 5};
```

第二种写法的花括号中有 5 个数，所以系统会自动定义数组 a 的长度为 5。但是要注意，只有在定义数组时就初始化才可以这样写。如果定义数组时不初始化，那么省略数组长度就是语法错误。比如：

```
int a[];
```

那么编译时就会提示错误，编译器会提示你没有指定数组的长度。

#### 2. 二维数组
二维数组定义的一般形式是：
`类型说明符 数组名[常量表达式1][常量表达式2]`
其中常量表达式1表示第一维下标的长度，常量表达式2 表示第二维下标的长度。例如：
```c
int a[3][4];
```
说明了一个三行四列的数组，数组名为a，其下标变量的类型为整型。
该数组的下标变量共有3×4个，即：
```
  a[0][0], a[0][1], a[0][2], a[0][3]
  a[1][0], a[1][1], a[1][2], a[1][3]
  a[2][0], a[2][1], a[2][2], a[2][3]
```
二维数组在概念上是二维的，即是说其下标在两个方向上变化，下标变量在数组中的位置也处于一个平面之中，而不是象一维数组只是一个向量。但是，实际的硬件存储器却是连续编址的，也就是说存储器单元是按一维线性排列的。如何在一维存储器中存放二维数组，可有两种方式：一种是按行排列， 即放完一行之后顺次放入第二行。另一种是按列排列， 即放完一列之后再顺次放入第二列。

在C语言中，二维数组是按行排列的。即，先存放a[0]行，再存放a[1]行，最后存放a[2]行。每行中有四个元素也是依次存放。由于数组a说明为int类型，该类型占两个字节的内存空间，所以每个元素均占有两个字节。

**二维数组元素的引用**
二维数组的元素也称为双下标变量，其表示的形式为：
`数组名[下标][下标]`
其中下标应为整型常量或整型表达式。例如：
 `a[3][4]`
表示a数组三行四列的元素。

下标变量和数组说明在形式中有些相似，但这两者具有完全不同的含义。数组说明的方括号中给出的是某一维的长度，即可取下标的最大值；而数组元素中的下标是该元素在数组中的位置标识。前者只能是常量，后者可以是常量，变量或表达式。

**二维数组元素的初始化**
二维数组初始化也是在类型说明时给各下标变量赋以初值。二维数组可按行分段赋值，也可按行连续赋值。
**对于二维数组初始化赋值还有以下说明：**
1) 可以只对部分元素赋初值，未赋初值的元素自动取0值。例如：

```
int a[3][3]={{1},{2},{3}};
```
是对每一行的第一列元素赋值，未赋值的元素取0值。 赋值后各元素的值为：
  1  0  0
  2  0  0
  3  0  0
```
int a [3][3]={{0,1},{0,0,2},{3}};
```
赋值后的元素值为：
  0  1  0
  0  0  2
  3  0  0

2) 如对全部元素赋初值，则第一维的长度可以不给出。例如：
```
int a[3][3]={1,2,3,4,5,6,7,8,9};
```
可以写为：
```
int a[][3]={1,2,3,4,5,6,7,8,9};
```
3) 数组是一种构造类型的数据。二维数组可以看作是由一维数组的嵌套而构成的。设一维数组的每个元素都又是一个数组，就组成了二维数组。当然，前提是各元素类型必须相同。根据这样的分析，一个二维数组也可以分解为多个一维数组。C语言允许这种分解。
如二维数组`a[3][4]`，可分解为三个一维数组，其数组名分别为：
  a[0]
  a[1]
  a[2]
对这三个一维数组不需另作说明即可使用。这三个一维数组都有4个元素，例如：一维数组`a[0]`的元素为`a[0][0],a[0][1],a[0][2],a[0][3]`。必须强调的是，`a[0],a[1],a[2]`不能当作下标变量使用，它们是数组名，不是一个单纯的下标变量。

#### 3. 字符数组
**1、字符数组的定义**
`char word[] = {‘H’, ‘e’, ‘l’, ‘l’, ‘o’,‘!’,’\0’};`
以0（整数0）结尾的⼀串字符
0或`’\0’`是⼀样的，但是和’0’不同
0标志字符串的结束，但它不是字符串的⼀部分
计算字符串⻓度的时候不包含这个0
字符串以数组的形式存在，以数组或指针的形式访问
更多的是以指针的形式
**2、字符数组与字符串**
• `"Hello" `
• `"Hello"` 会被编译器变成⼀个字符数组放在某处，这
个数组的⻓度是6，结尾还有表⽰结束的0 
• 两个相邻的字符串常量会被⾃动连接起来
• ⾏末的\表⽰下⼀⾏还是这个字符串常量

********
• C语⾔的字符串是以字符数组的形态存在的
• 不能⽤运算符对字符串做运算
• 通过数组的⽅式可以遍历字符串
• 唯⼀特殊的地⽅是字符串字⾯量可以⽤来初始化字符
数组
• 以及标准库提供了⼀系列字符串函数
********
char`*`s = "Hello, world!";
• s 是⼀个指针，初始化为指向⼀个字符串常量
• 由于这个常量所在的地⽅，所以实际上s是 const 
char`*` s ，但是由于历史的原因，编译器接受不带
const的写法
• 但是试图对s所指的字符串做写⼊会导致严重的后果
• 如果需要修改字符串，应该⽤数组：`char s[] = "Hello, world!";`

**指针还是数组？**
• `char *str = "Hello";`
• `char word[] = "Hello";`
• 数组：这个字符串在这⾥
• 作为本地变量空间⾃动被回收
• 指针：这个字符串不知道在哪⾥
• 处理参数
• 动态分配空间

- 如果要构造⼀个字符串—>数组
+ 如果要处理⼀个字符串—>指针

**3、字符串的表示形式**
在C语言中，可以用两种方法表示和存放字符串：
（1）用字符数组存放一个字符串
`char str[]="I love China";`
（2）用字符指针指向一个字符串
`char* str="I love China";`
对于第二种表示方法，有人认为str是一个字符串变量，以为定义时把字符串常量"I love China"直接赋给该字符串变量，这是不对的。
C语言对字符串常量是按字符数组处理的，在内存中开辟了一个字符数组用来存放字符串常量，程序在定义字符串指针变量str时只是把字符串首地址（即存放字符串的字符数组的首地址）赋给str。

**两种表示方式的字符串输出都用**
`printf("%s\n",str);`
%s表示输出一个字符串，给出字符指针变量名str（对于第一种表示方法，字符数组名即是字符数组的首地址，与第二种中的指针意义是一致的），则系统先输出它所指向的一个字符数据，然后自动使str自动加1，使之指向下一个字符...，如此，直到遇到字符串结束标识符 `" \0 "`。

• 字符串可以表达为char*的形式 • char*不⼀定是字符串 • 本意是指向字符的指针，可能指向的是字符 的数组（就像int*⼀样） • 只有它所指的字符数组有结尾的0，才能说它 所指的是字符串



**4、对使用字符指针变量和字符数组两种方法表示字符串的讨论**
虽然用字符数组和字符指针变量都能实现字符串的存储和运算，但它们二者之间是有区别的，不应混为一谈。
4.1、字符数组由若干个元素组成，每个元素放一个字符；而字符指针变量中存放的是地址（字符串/字符数组的首地址），绝不是将字符串放到字符指针变量中（是字符串首地址）
4.2、**赋值方式：**   对字符数组只能对各个元素赋值，不能用以下方法对字符数组赋值

```
char str[14];
str="I love China";
//（但在字符数组**初始化**时可以，即char str[14]="I love China";）
```
而对字符指针变量，采用下面方法赋值：
```
char* a;
a="I love China";
```
或者是`char* a="I love China";`都可以

4.3、对字符指针变量赋初值（**初始化**）：
`char* a="I love China";`
等价于：
```
char* a;
a="I love China";
```
而对于字符数组的初始化
`char str[14]="I love China";`
不能等价于：
```
char str[14];
str="I love China"; （这种不是初始化，而是赋值，而对数组这样赋值是不对的）
```
4.4、如果定义了一个字符数组，那么它有确定的内存地址；而定义一个字符指针变量时，它并未指向个确定的字符数据，并且可以多次赋值。

***********

**5、字符串处理函数**

**注意：**在使用字符串处理函数函数时应当在程序文件的开头用`#include <string.h>`。

- puts函数
  - 输出字符串：`puts(字符数组)`

- gets函数
  - 输入字符串：`gets(字符数组)`

- strcat函数
  - 字符串连接函数：`strcat（字符串数组1，字符串数组2）`

- strcpy函数

  - 字符串复制函数：`strcpy（字符串数组1，字符串数组2）`

- strncpy函数

  - 字符串复制函数：`strncpy（字符串数组1，字符串数组2，n）`，`n`为常数
  - 把字符串数组2中前面`n`个字符复制到字符串数组1中

- strcmp函数

  - 字符串比较函数：`strcmp(字符串数组1，字符串数组2)`

  - 比较规则：将两个字符串自左向右逐个字符相比（按ASCII码值大小比较），直到出现不同的字符或遇到`‘\0’`为止。

    >1.如果字符串数组1与字符串数组2相同，则返回函数值为0。
    >
    >2.如果字符串数组1>字符串数组2相同，则返回函数值为一个正整数。
    >
    >3.如果字符串数组1<字符串数组2相同，则返回函数值为一个负整数。

- strlen函数

  - 测字符串长度：`strlen(字符串数组)`
  - 函数的值为字符串中的实际长度（不包括`'\0'`在内）

- strlwr函数

  - 转换为小写：`strlwr(字符串数组)`

- strupr函数

  - 转换为小写：`strupr(字符串数组)`

### 第四章、函数实现模块化设计

#### 1. 定义函数的方法

函数体包括**声明部分**和**语句部分**

- 定义无参函数

一般形式为：

```
类型名 函数名(){
	函数体
}
或
类型名 函数名(void){
	函数体
}
```

- 定义有参函数

一般形式为：

```
类型名 函数名(形式参数列表){
	函数体
}
```

- 定义空参函数
  - 函数体是空的。调用此函数时，什么工作也不做，没有任何实际作用。

一般形式为：

```
类型名 函数名()
{}
```
#### 2. 调用函数

**调用函数的形式**

一般的调用形式为：

```C
函数名(实参表列);
```

函数调用语句：把函数调用单独作为一个语句。

函数表达式：函数出现在另一个表达式中。

函数参数：函数调用作为另外一个函数调用时的参数。

**函数作为参数时的数据传递**
*【函数形式参数和实际参数】*

函数的参数分为两种，分别是形式参数与实际参数。

①形式参数：

在定义函数时函数名后面括号中的变量名称称为形式参数（简称形参），即形参出现在函数定义中。形参变量只有在被调用时才会为其分配内训单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只在函数内部有效，只有当函数被调用时，系统才为形参分配存储单元，并完成实参与形参的数据传递。在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。

②实际参数：

主调函数中调用一个函数时，函数名后面括号中的参数称为实际参数（简称实参），即实参出现在主调函数中。

实参可以是常量，变量，表达式，函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传递给形参。因此应预先用赋值，输入等办法使实参获得确定值。

说明：在被定义的函数中，必须指定形参的类型。实参与形参的类型应相同或赋值兼容。实参和形参在数量上，类型上，顺序上应该严格一致，否则会发生类型不匹配的错误。

#### 3. 函数的返回值

1. 函数的返回值是通过函数中的return语句获得的。

   【return语句将被调用函数中的一个确定值带回到主函数中去。】

2. 函数值的类型。既然函数有返回值，这个值当然应属于某一个确定的类型，应当在定义函数时指定函数值的类型。

   【注意：在定义函数时要指定函数的类型。】

3. 在定义函数时指定的函数类型一般应该和return语句中的表达式类型一致。

   【如果函数的类型和return语句中表达式的值不一致，则以函数类型为准。对数值型数据，可以自动进行类型转换。即**函数类型决定返回值的类型。**】

4. 对于不带回值的函数，应当用定义函数为**void类型（或称“空类型”）**

#### 4. 对被调用函数的声明和函数原型

在一个函数中调用另一个函数（即被调用函数）需要具备如下条件：

- 首先被调用的函数必须是已经定义的函数（函数库或用户自定义的函数）。

- 如果使用函数，应该在本文件头用`#include`指令将调用有关库函数时所需用的到的信息“包含”到文件中来。

- 如果使用用户自定义的函数，而该函数的位置在调用它的函数（即主函数）的后面（在同一个文件中），应该在主函数中对被调用的函数作**声明（delcaration）**。声明的作用是把函数名、函数参数的个数和参数类型等信息通知编译系统，以便在遇到函数调用时，编译系统能正确识别到函数并检查调用是否合法。

函数声明的一般形式有两种：

方式一：

```txt
函数类型 函数名(参数类型1 参数名1,参数类型2 参数名2,…,参数类型n 参数名n);
```

方式二：

```txt
函数类型 函数名(参数类型1,参数类型2,…,参数类型n);
```

**注意：**

函数的 “定义“ 和 ”声明“ 不是同一回事。

- 函数的定义是指对函数功能的确立，包括指定函数名、函数值类型、形参及其类型以及函数体等，它是一个完整的、独立的函数单位。
- 函数声明的作用则是把函数的名字、函数类型以及形参的类型、个数和顺序通知编译系统，以便在调用该函数时系统按此进行对照检查，它不包含函数体。

#### 5. 数组作为函数参数

**数组元素作函数实参**

数组元素可以用作函数实参，但是不能用作形参。因为形参是在函数被调用时临时分配的存储单元，不可能为一个数组元素单独分配存储单元（数组是一个整体，在内存中占连续的一段存储单元）。在用数组元素作函数参数实参时，把实参的值传给形参，是 ”值传递“ 方式。数据传递方向是从实参传到形参，单向传递。

**一维数组名作函数参数**

除了可以用数组元素作为函数参数外，还可以用数组名作函数参数（包括实参和形参）。

注意：用数组元素作实参时，向形参变量传递的是数组元素的值，而用数组名作函数函数参数时，向形参（数组名或指针变量）传递的是地址值。

**多维数组名作函数参数**

由于用法基本一致，其余不做详细介绍。

请参考：《C语言程序设计（第五版）》——谭浩强 【第七章- 用函数实现模块化程序设计 -167页】 

#### 6. 局部变量和全局变量

变量按存储区域分：全局变量、静态全局变量和静态局部变量都存放在内存的静态存储区域，局部变量存放在内存的栈区。

变量按作用域分：
- 全局变量：在整个工程文件内都有效；“在函数外定义的变量”，即从定义变量的位置到本源文件结束都有效。由于同一文件中的所有函数都能引用全局变量的值，因此如果在一个函数中改变了全局变量的值， 就能影响到其他函数中全局变量的值。

- 静态全局变量：只在定义它的文件内有效，效果和全局变量一样，不过就在本文件内部；

- 静态局部变量：只在定义它的函数内有效，只是程序仅分配一次内存，函数返回后，该变量不会消失；静态局部变量的生存期虽然为整个工程，但是其作用仍与局部变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。 　　　　

- 局部变量：在定义它的函数内有效，但是函数返回后失效。“在函数内定义的变量”，即在一个函数内部定义的变量，只在本函数范围内有效。

注意：全局变量和静态变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知

静态局部变量与全局变量最明显的区别就在于：全局变量在其定义后所有函数都能用，但是静态局部变量只能在一个函数里面用。

形参变量 :  只在被调用期间才分配内存单元，调用结束立即释放。

#### 7.变量的存储方式和生存期

**变量的存储方式有两种：**

- 静态存储方式：是指程序在运行期间由系统分配固定的存储空间的方式。

- 动态存储方式：是指在程序运行期间根据需要进行动态的分配存储空间的方式。

供用户使用的存储空间可分为3个部分：程序区，静态存储区，动态存储区。

全局变量全部存放在静态存储区中，在程序开始执行时给全局变量分配存储区，程序执行完毕就释放。

**动态存储区中存放以下数据：**

1. 函数形式参数。在调用函数时给形参分配存储空间。
2. 函数中定义的没有用static关键字声明的变量，即自动变量。
3. 函数调用时的现场保护和返回地址等。

每一个变量和函数都有两个属性：数据类型和数据的存储类别。【存储类别指的是数据在内存中存储的方式：静态存储和动态存储】

在定义和声明变量和函数时，一般应该同时指定其数据类型和存储类别，也可以采用默认方式指定（即如果用户不指定，系统会隐含地指定为某一种存储类别）。

**存储类别包括4种：**自动的（auto）、静态的（static）、寄存器的（register）、外部的（extern）。

- 自动变量（auto变量）

  - 函数中的局部变量，如果不专门声明为static（静态）存储类别，都是动态地分配存储空间的，数据存储在动态存储区中。函数的形参和在函数定义的局部变量（包括在复合语句中定义的局部变量），都属于此类。在调用该函数时，系统会给这些变量分配存储空间，在函数调用调用结束时就自动释放这些存储空间。因此这类局部变量称为自动变量。

  - 关键字auto可以省略不写，不写auto则隐含的指定为 “自动存储类别” ，它属于动态存储的方式。程序中大多数变量都属于自动变量。

- 静态局部变量（static局部变量）

  - 静态局部变量属于静态存储类别，在静态存储区域内分配存储单元。在整个程序运行期间都不释放。而自动变量（即动态局部变量）属于动态存储类别，分配在动态存储区空间而不再静态存储区空间，函数调用结束后即释放。
  - 对静态局部变量是在编译时赋初值的，即只赋一次初值，在程序运行时它已有初值。以后每次调用函数函数时不再重新赋初值而只是保留上次函数调用结束时的值。而对自动变量赋初值，不是在编译时进行的，而是在函数调用时进行的，每调用一次函数重新给一次初值，相当于执行一次赋值语句。
  - 如果在定义局部变量时不赋值的话，则对静态局部变量来说，编译时自动赋初值0（对数值变量）或空字符`'\0'`（对字符变量）。而对自动变量来说，它的值是一个不确定的值。这是由于每次函数调用结束后存储单元已释放，下次调用时又重新另分配存储单元，而所分配的单元中的内容是不可加的。
  - 虽然静态局部变量在函数调用结束后仍然存在，但其他函数是不能引用他的。因为它是局部变量，只能被本函数引用，而不能被其他函数引用。

- 寄存器变量（register变量）

  - 寄存器变量的定义形式是：

    `register 类型标识符 变量名`

  - 寄存器是与机器硬件密切相关的，不同类型的计算机，寄存器的数目是不一样的，通常为2到3个，对于在一个函数中说明的多于2到3个的寄存器变量，C编译程序会自动地将寄存器变量变为自动变量。

  - 由于受硬件寄存器长度的限制，所以寄存器变量只能是char、int或指针型。寄存器说明符只能用于说明函数中的变量和函数中的形参，因此不允许将外部变量或静态变量说明为"register"。

  - register型变量常用于作为循环控制变量，这是使用它的高速特点的最佳场合。比较下面两个程序的运算速度。

- 注意三种局部变量的存储位置是不同的
  - 自动变量存储在动态存储区
  - 静态局部变量存储在静态存储区
  - 寄存器存储在CPU中的寄存器中

**全局变量的存储类别**

- 在一个文件内扩展外部变量的作用域
  - 如果外部变量不在文件的开头定义,其有效的作用范围只限于定义处到文件结束。在定义点之前的函数不能引用该外部变量。如果由于某种考虑，在定义点之前的函数需要引用该外部变量,则应该在引用之前用关键字`extern`对该变量作**“外部变量声明”**，表示把该外部变量的作用域扩展到此位置。有了此声明，就可以从 “声明” 处起,合法地使用该外部变量。
  - 注意：提倡将外部变量的定义放在引用它的所有函数之前，这样可以避免在函数中多加一个`extern`声明。
  - 用`extern`声明外部变量时，类型名也可以省写。例如：`extern int A,B,C;`——>`extern A,B,C` 。
- 将外部变量的作用域扩展到其他文件
  - 第一种情况是在同一个源文件中使用外部变量的方法，如果有多个源文件，想在A文件中引用B文件中的已定义外部变量，该如何做？
  
    - 假设一个程序包含两个文件，两个文件都需要用到同一个外部变量Num,若在两个文件中各自定义一个外部变量Num，将会在进行程序的连接时出现“重复定义”的错误。
  
    - 因此，正确的做法是：在任一个文件中定义外部变量Num，然后在另一个文件中用关键字extern进行“外部变量声明”，即“extern Num”。
	
    - 在编译和链接时，系统就会知道Num有外部链接，可以从别处找到已定义的外部变量Num，并将另一个文件中定义的外部变量Num的作用域扩展到本文件，那么就可以在本文件中合法的使用变量Num了。

    - 例子：分别编写两个源文件文件file1和file2,在file1中定义外部变量A,在file2中用extern来声明外部变量，把A的作用域扩展到file2中

file1:
```c
    //file1
    #include<stdio.h>
    //给定b的值，输入a和m，求a*b和a**m(a的m次方)的值
  
    int A;     //定义外部变量
    int power(int);
    int main()
    {
    	int b = 3, c, d, m;
    	printf("input a and its power m:");
    	scanf_s("%d %d", &A, &m);
    	c = A * b;
    	printf("%d*%d=%d\n", A, b, c);
    	d = power(m);
    	printf("%d ** %d=%d\n", A, m, d);
    	system("pause");
    }
```
file2:
```c
    //file2
    extern A;             
    //把在file1文件中已定义的外部变量的作用域扩展到本文件
    int power(int n)
    {
    	int i, y = 1;
    	for ( i = 1; i <= n; i++)
    	{
    		y *= A;
    	}
  
    	return y;
    }
```
运行结果：

![](https://cdn.jsdelivr.net/gh/wfmiss/pictures/C_language/20210510175612.png)

- 解析：
  - 假设某一程序有5个源文件，那么只需要在其中一个源文件中定义外部变量A,然后在其余四个文件中使用关键字extern声明外部变量即可。各文件经过编译后会连接成一个可执行的目标文件。
  - 用这种方法扩展全局变量的作用域应十分慎重，因为在执行一个文件中的操作时可能会改变该全局变量的值，这样就会影响到另一个文件中全局变量的值，从而影响该文件中函数的执行结果。

- 将外部变量的作用域限制在本文件中
  - 若希望外部变量仅限于被本文件使用，而不被其它文件使用，那么可以在定义外部变量时加上一个static，例如：

```c
static int A;
int main()
{
	......
}
```
这样在其它文件中就算使用“extern A”，也不能使用本文件的外部变量A。
这种加上static声明，只能用于本文件的外部变量成为“静态外部变量”。
用static声明一个变量的作用：

（1）对局部变量用static声明，把它分配在静态存储区，该变量在整个程序执行期间所在的存储单元都不会释放。

（2）对全局变量用static声明，则该变量的作用域只限于本文件模块（即被声明的文件中）

#### 8. 存储类别小结

对数据的定义，需要指定两种属性：**数据类型**和**存储类别**，分别使用两个关键字。

例如：

```C
static int a;		//静态局部整型变量或静态外部整型变量
auto char c;		//自动变量，在函数内定义使用
register int d;		//寄存器变量，在函数内定义
```



此外，可以用`extern`声明已定义的外部变量，例如：

```c
extern b;		//将已定义的外部变量b的作用域扩展至此
```

**下面从不同角度做些归纳**

1. 从作用域角度分，有局部变量和全局变量。它们采用的存储类型如下：

   

   ![](https://cdn.jsdelivr.net/gh/wfmiss/pictures/C_language/20210510211854.png)



2. 从变量存在的时间（生存期）来区分，有动态存储和静态存储两种类型。静态存储类型是整个程序运行时间都存在，而动态存储原则是在调用函数时临时分配分配单元。

   

   ![](https://cdn.jsdelivr.net/gh/wfmiss/pictures/C_language/20210510222624.png)

3. 从变量值存放的位置来区分，可分为：

![](https://cdn.jsdelivr.net/gh/wfmiss/pictures/C_language/20210510233802.png)

************

4. 关9.作用域和生存期的概念。

- 如果一个变量在某个文件或函数范围内是有效的，就称为该范围为该变量的**作用域**。在此作用域内可以引用该变量，在专业书中称变量在此作用域内 “可见” ，这种性质称为变量的可见性。

- 如果一个变量值在某一时刻是存在的，则认为这一时刻属于该变量的生存期，或称该变量在此时刻 “存在” 。

**各种类型变量的作用域和存在性情况**

![](https://cdn.jsdelivr.net/gh/wfmiss/pictures/C_language/20210511000340.png)

5. `static`对局部变量和全局变量的作用域不同。对于局部变量来说它使变量的由动态存储方式改变为静态存储方式。而对于全局变量来说，它使变量局部化（局部于本文件）,但静态存储方式。从作用域角度看，但凡有`static`声明的，其作用域都是局限的或者局限于本函数内（静态局部变量），或者局限于本文件内（静态外部变量）。

#### 9. 内部函数和外部函数

根据函数能否被其他源文件调用，将函数区分为**内部函数**和**外部函数**。

**内部函数**

如果一个函数只能被本文件中其他函数所调用，它将称为**内部函数**。

在定义内部函数时，在函数名和函数类型前面加`static`,即：

```c
static 类型名 函数名(形参表);
```

内部函数又称**静态函数**，因为它是`static`声明的。

**外部函数**

 如果在定义函数时，在函数首部的最左端加关键字`extern`，则此函数是外部函数，可供其他文件调用。

一般形式为：

```c
extern 类型名 函数名(形参表);
```

C语言规定，如果在定义函数时省略`extern`，则默认为外部函数。

在需要调用此函数的其他文件中，需要对此函数作声明（不要忘记，即使在本文件中调用一个函数，也需要用函数原型进行声明）。在对此函数作声明时，要加关键字`extern`，表示该函数 “是在其他文件中定义的外部函数” 。

### 第五章、 指针【C语言的灵魂】

#### 1. 指针及指针变量【概念、定义】

定义指针变量：`类型名称 *指针变量名;`

**在定义指针变量时要注意：**

1. 指针变量前面的“`*`”表示该变量为指针型变量。
2. 在定义指针变量时必须**指定基类型。**指针的基类型用来定义此指针变量可以指向的变量的类型。一个变量的指针的含义包括两个方面，一是存储单元编号表示的纯地址，一是它指向的存储单元的数据类型（如int、char、float等）。
3. 指向整型数据的指针类型表示为“`int*`”，读作**“指向int的指针”**或简称**“int指针”**。【`int*,float*,char*`，是三种不同的类型，不能混淆】
4. 指针变量中只能存放地址（指针），不要将一个整数赋给指针变量。
   - 如:`*pointer_1=100;      //pointer_1是指针变量，100是整数，不合法`

如果需要取出某个变量的地址，可以使用取址运算符`&`:

例如：

```c
char *pa = &a;
int *pb = &b;
```

如果需要访问指针变量指向的数据类型，可以使用取值运算符`*`:

例如：

```c
printf("%c,%d\n",*pa,*pb);
```

*******

访问地址里的值的两种方式：

直接访问：即按变量名进行的访问。

间接访问：即通过指针变量进行的访问。

**注意**：避免访问未初始化的指针。【因为未初始化的指针指向的地址是随机的，未初始化就使用是非常危险的！！！】

例如：【以下示例为**错误的**】

```c
#include <stdio.h>
main(){
	int  *a;
    *a = 123;
}
```

**指针与指针变量**

如果有一个**变量**专门来存放另一变量的**地址（即指针）**，则称它为**“指针变量”**。

指针变量就是地址变量，用来存放地址，**指针变量的值就是地址（即指针）。**

**注意：**区分 “指针” 和 “指针变量” 这两个概念。**指针就是一个地址，而指针变量是存放地址值的变量。**

#### 2. 引用指针变量

在引用指针变量时，可能有3种情况：

- 给指针变量赋值。
  - 如：`p = &a;		//把 a 的地址赋给指针变量 p `。
  - 指针变量p的值是变量a的地址，p指向a。
- 引用指针变量指向的变量。
  - 如果已经执行`p=&a;`，即指针变量p指向了整型变量a，则`printf("%d",*p);`
  - 其作用是以整数形式输出变量p指向的变量的值，即变量a的值。
- 引用指针变量的值。
  - 如：`printf("%o",p);`
  - 其作用是以八进制整数输出指针变量的值，如果p指向变量a，就是输出了a的地址，即&a。

**注意：要熟练掌握两个有关运算符。**

- `&` 取地址运算符。&a是变量a的地址。
- `*` 指针运算符（或称“间接访问”运算符），`*p`代表指针变量p指向的对象。

*****

**指针变量作为函数参数**

函数的参数不仅可以是整数型、浮点型、字符型等数据，还可以是指针类型。它的作用是将一个变量的地址传送到另一个函数中。

注意：不能企图通过改变指针形参的值而使指针实参的值改变。

*****

#### 3. 通过指针引用数组

指针变量既然可以指向变量，当然也可以指向数组元素（把某一元素的地址放到一个指针变量中）。所谓数组元素的指针就是数组元素的地址。

将数组元素地址赋值给指针变量，如：

```c
int a[10]={1,3,5,7,9,11,13,15,17,19};//定义a为包含10个整型数据的数组
int *P;								 //定义p为指向整型变量的指针变量
p = &a[0];							 //把a[0]元素的地址赋给指针变量p
```

下标法赋值：

`指针变量 = &数组名[数值];` 将下表为 `数组名[数值]` 的元素地址，赋值给 `指针变量`。

不加标赋值：

`指针变量 =  数组名;`将数组的首元素【即`数组名[0]`】地址赋值给`指针变量`。

下面两个语句等价：

```c
int *p;
 p = &a[0];
-------------------
int *p;
p = a;
```

**引用数组元时指针的运算**

在指针已指向一个数组元素时，可以对指针进行以下运算：

- 加一个整数（用`+或+=`），如`p+1`；
- 减一个整数（用`-或-=`），如`p-1`；
- 自加运算，如：`p++;  ++p;`
- 自减运算，如：`p--; --p;`

两指针相减，如：`p1-p2`（只有p1和p2都指向同一数组中的元素时才有意义）。

分别说明如下：

- 如果指针变量p已指向数组中的一个元素，则p+1指向同一数组中的下一个元素，p-1指向同一数组元素中的上一个元素。
  - 注意：执行p+1时并是将p的值（地址）简单的加1，而是加上一个数组元素所占的字节数。
  - 例如：数组元素是float型，每个元素是float型，每个元素占4个字节，则p+1意味着使p的值（地址）加4个字节，以使它指向下一元素。
- 如果p的初值为`&a[0]`,则表示`p+i`和`a+i`就是数组元素`a[i]`的地址。
- `*(p+i)`或`*(a+i)`是`p+i`或`a+i`所指向的数组元素，即`a[i]`。
  - 说明：`[]`实际上是变址运算符，即将`a[i]`按`a+i`计算然后找出此地址单元中的地址。
- 如果指针变量`p1`和`p2`都指向同一组数组中的元素，如执行`p2-p1`,结果是`p2-p1`的值（两个地址之差）除以数组元素的的长度。
  - 注意：两个地址不能相加，如`p1+p2`是无实际意义的。

*******

**通过指针引用数组元素**

引用一个数组元素，可以用下面两种方法：

- 下标法：如`a[i]`形式；
- 指针法：如`*(a+i)`或`*(p+i)`。其中 `a` 是数组名，`p` 是指向数组元素的指针变量，其初值`p=a`。

指向数组元素的指针变量也可以带下标，如`p[i]`。

`++` 和 `*` 同优先级，结合方向为自左向右。

`*(p++)与*(++p)`，作用不相同。

- `*(p++)`:是先取`*p`的值，然后使`p+1`。
- `*(++p)`:是先`p+1`，然后再取`*p`的值。

`++(*p)`：表示`p`所指向的元素值加1。

`--(*p)`：表示`p`所指向的元素值减1。

所以：

- `*(++p)`相当与`a[++i]`，先使p自加，再进行`*`运算。
- `*(--p)`相当与`a[--i]`，先使p自减，再进行`*`运算。

**用数组名做函数参数**

数组名做函数参数方法定义一般形式为：

```C
返回值类型 方法名(参数类型 数组名[],参数列表……){
    方法体;
    返回值;
}
```

指针做函数参数定义一般形式为：

```C
返回值类型 方法名(参数类型 *数组名,参数列表……){	//这里的 “*数组名” 表示数组的首元素地址 “数组名[0]”
    方法体;
    返回值;
}
```

两种定义方法等价。

`*数组名`等价于`数组名[0]`。

**注意：**数组名做方法参数时，传递的是数组首元素的地址，而非元素值。

常用这种方法通过调用一个函数来改变实参数组的值。

*以表变量名和数组名作为函数参数的比较*

| 参数类型                     | 变量名               | 数组名             |
| ---------------------------- | -------------------- | ------------------ |
| 要求的形参类型               | 变量名               | 数组名或指针       |
| 传递参数                     | 变量的值             | 实参数组首元素地址 |
| 通过函数调用能否改变实参的值 | 不能改变实参变量的值 | 能改变实参数组的值 |

**注意：**实参数组名代表一个固定的地址，或者说是指针常量，但形参数组名并不是一个固定的地址，而是按指针变量处理。

在函数调用进行虚实结合后，形参的值就是实参数组首元素的地址。在函数执行期间，它还可以再被赋值。

**归纳分析：**如果有一个实参数组，想要在函数中改变此数组中的元素的值，实参与形参的对应关系有以下4种情况。

- 形参和实参都用数组名。
  - 例如：

```c
int main(){
    int a[10];
    ...
    f(a,10);
    ...
}
int f(int x[],int n){
    ...
}
//由于形参数组名x接收了实参数组首元素a[0]的地址值，因此可以认为在函数调用期间，形参数组与实参数组共用一段内存单元。
```

- 实参用数组名，形参用指针变量。
  - 例如：

```c
int main(){
    int a[10];
    ...
    f(a,10);
    ...
}
void f(int *x,int n){
    ...
}
//实参a为数组名，形参数组x为int * 型的指针变量，调用函数开始后，形参x指向a[0],即x=&a[0]。通过x的值改变，可以指向a数组的任一元素。
```

- 实参形参都用指针变量。
  - 例如：

``` c
int main(){
    int a[10], *p = a;
    ...
    f(p,10);
    ...
}
void f(int *x,int n){
    ...
}
//实参p和形参x都是int * 型的指针变量。先使实参指针变量p指向数组a[0]，p的值是&a[0]。然后将p的值传给指针变量x，x的初始值也是&a[0],通过x值的改变可以使x指向数组元素a的任一元素。
```

- 实参为指针变量，形参为数组名。
  - 例如：

```c
int main(){
    int a[10], *p = a;
    ...
    f(p,10);
    ...
}
void f(int x[],int n){
    ...
}
//实参p为指针变量，它指向a[0]。形参为数组名x，编译系统把x作为指针变量处理，今将a[0]的地址传给形参x，使x也指向a[0]。也可以理解为形参数组x和a数组共用同一段内存单元。在函数执行过程中可以使x[i]的值发生变化，而x[i]就是a[i]。
```

**注意：**如果使用指针变量作实参，必须先使指针变量有确定值，指向一个以定义的对象。

以上4种方法，实质上都是地址的传递。其中（3）、（4）两种只是形式上的不同，实际上形参都是使用指针变量。

**通过指针引用多维数组**

